#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

PID_FILE="$SCRIPT_DIR/znode.pid"
LOG_FILE="$SCRIPT_DIR/znode.log"
P2P_DAEMON_DIR="$SCRIPT_DIR/p2p-daemon"
P2P_DAEMON_BIN="$P2P_DAEMON_DIR/p2p-daemon"
MAX_LOG_SIZE="${MAX_LOG_SIZE_MB:-100}"  # Default 100MB
MAX_LOG_FILES="${MAX_LOG_FILES:-5}"     # Keep 5 rotated logs

# Log rotation function
rotate_logs() {
  if [ ! -f "$LOG_FILE" ]; then
    return
  fi
  
  local size_mb=$(du -m "$LOG_FILE" 2>/dev/null | cut -f1)
  if [ "$size_mb" -ge "$MAX_LOG_SIZE" ]; then
    echo "[start] Rotating log file (${size_mb}MB >= ${MAX_LOG_SIZE}MB)"
    
    # Rotate existing logs
    for i in $(seq $((MAX_LOG_FILES - 1)) -1 1); do
      if [ -f "${LOG_FILE}.$i" ]; then
        mv "${LOG_FILE}.$i" "${LOG_FILE}.$((i + 1))"
      fi
    done
    
    # Move current log to .1
    mv "$LOG_FILE" "${LOG_FILE}.1"
    
    # Remove oldest log if exceeds max
    if [ -f "${LOG_FILE}.$((MAX_LOG_FILES + 1))" ]; then
      rm -f "${LOG_FILE}.$((MAX_LOG_FILES + 1))"
    fi
  fi
}

# Build Go p2p-daemon (always rebuild to pick up code changes)
build_p2p_daemon() {
  echo "[start] Building Go p2p-daemon..."
    
    # Prefer /usr/local/go if it exists (may be newer than system Go)
    if [ -x "/usr/local/go/bin/go" ]; then
      export PATH="/usr/local/go/bin:$PATH"
    fi
    
    # Check if Go is installed
    if ! command -v go &> /dev/null; then
      echo "[start] ERROR: Go is not installed. Please install Go 1.24+ first."
      echo "[start] Run: wget -q https://go.dev/dl/go1.24.0.linux-amd64.tar.gz && sudo tar -C /usr/local -xzf go1.24.0.linux-amd64.tar.gz"
      exit 1
    fi
    
    # Build the daemon
    (cd "$P2P_DAEMON_DIR" && go build -o p2p-daemon .) || {
      echo "[start] ERROR: Failed to build p2p-daemon"
      exit 1
    }
    
    echo "[start] âœ“ p2p-daemon built successfully"
}


# Ensure P2P port is open
ensure_firewall() {
  local P2P_PORT=9000
  
  # Check if ufw is available and active
  if command -v ufw &> /dev/null; then
    if ufw status | grep -q "Status: active"; then
      # Check if port is already allowed
      if ! ufw status | grep -q "$P2P_PORT/tcp.*ALLOW"; then
        echo "[start] Opening P2P port $P2P_PORT in firewall..."
        ufw allow $P2P_PORT/tcp >/dev/null 2>&1 || echo "[start] Warning: Failed to open port $P2P_PORT"
      fi
    fi
  fi
  
  # Also try iptables directly as fallback (for non-ufw systems)
  if command -v iptables &> /dev/null; then
    # Check if port is blocked (no ACCEPT rule)
    if ! iptables -L INPUT -n 2>/dev/null | grep -q "dpt:$P2P_PORT.*ACCEPT"; then
      # Only add rule if iptables has other rules (i.e., it's being used)
      if iptables -L INPUT -n 2>/dev/null | grep -q "DROP\|REJECT"; then
        echo "[start] Adding iptables rule for port $P2P_PORT..."
        iptables -I INPUT -p tcp --dport $P2P_PORT -j ACCEPT 2>/dev/null || true
      fi
    fi
  fi
}

if [ -f "$PID_FILE" ]; then
  PID="$(cat "$PID_FILE" 2>/dev/null || true)"
  if [ -n "${PID}" ] && kill -0 "$PID" 2>/dev/null; then
    echo "[start] znode is already running with PID $PID"
    exit 0
  else
    echo "[start] Removing stale pidfile"
    rm -f "$PID_FILE"
  fi
fi

# Rotate logs before starting
rotate_logs

# Build p2p-daemon if needed
build_p2p_daemon

# Ensure firewall allows P2P port
ensure_firewall

echo "[start] Starting Monero wallet RPC..."
./start-monero-rpc.sh || { echo "[start] Failed to start Monero RPC"; exit 1; }

echo "[start] Starting znode..."
nohup node node.js >> "$LOG_FILE" 2>&1 &
PID=$!
echo "$PID" > "$PID_FILE"

echo "[start] znode started with PID $PID (logs: $LOG_FILE)"
echo "[start] Note: Go p2p-daemon will be spawned by node.js automatically"
